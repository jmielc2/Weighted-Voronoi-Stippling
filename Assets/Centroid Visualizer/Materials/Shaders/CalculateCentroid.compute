#pragma kernel Condense
#pragma kernel Reduce
#pragma use_dxc

RWTexture2D<float4> _VoronoiDiagram;
RWStructuredBuffer<float4x4> _PositionMatrixBuffer;
RWStructuredBuffer<float3> _ColorBuffer;

uniform uint _NumRegions;
uniform uint _ImageWidth, _ImageHeight;
uniform float _Width, _Height;

RWStructuredBuffer<float3> _WaveBuffer;
uniform uint _NumWavesPerDispatch;
uniform uint _Offset;

float2 PixelToWorldCoord(float2 pixel) {
    return float2(
        (((pixel.x + 0.5) / _ImageWidth) - 0.5) * _Width,
        (((pixel.y + 0.5) / _ImageHeight) - 0.5) * _Height
    );
}

// Centroid Algorithm
/*
Part One: Condense
2) Ballot wave front with predicate that checks if pixelVoronoiId == voronoiId.
3) Divide voronoiPixelIndex by count for pixels where pixelVoronoiId == voronoiId
4) Sum dividends using WaveActiveSum and write sum into waveBuffer
5) AllMemoryBarrierWithGroupSync to guarantee all waves have completed

Part Two: Reduce
6) id.y now represents waveId.
7) Reduce all warpSums to single value using WaveActiveSum and parallel reduction technique.
8) warpSum represents average voronoiPixelIndex for voronoi with ID of voronoiId, so convert to float2 to get centroid.
*/

// https://developer.download.nvidia.com/assets/cuda/files/reduction.pdf
[numthreads(1, 32, 1)]
void Condense(uint3 dispatchId : SV_DispatchThreadID, uint3 groupId : SV_GroupId)
{
    if (dispatchId.y >= _ImageWidth * _ImageHeight)
    {
        return;
    }
    uint2 pixelPosition = uint2(dispatchId.y, floor(dispatchId.y / _ImageWidth));
    pixelPosition.x -= pixelPosition.y * _ImageWidth;
    const uint pixelVoronoiId = floor(_VoronoiDiagram[pixelPosition].r * _NumRegions + 0.5);
    bool isActive = (pixelVoronoiId == dispatchId.x);
    uint count = WaveActiveCountBits(isActive);
    if (count == 0)
    {
        _WaveBuffer[(dispatchId.x * _NumWavesPerDispatch) + groupId.y] = float3(0, 0, 0);
        return;
    }
    if (!isActive)
    {
        return;
    }
    float2 centroidPos = float2(0, 0);
    float2 worldPos = PixelToWorldCoord(pixelPosition);
    centroidPos.x = WaveActiveSum(worldPos.x);
    centroidPos.y = WaveActiveSum(worldPos.y);
    if (WaveIsFirstLane()) {
        _WaveBuffer[(dispatchId.x * _NumWavesPerDispatch) + groupId.y] = float3(centroidPos, count);
    }
    AllMemoryBarrier();
}

[numthreads(1, 32, 1)]
void Reduce(uint3 id : SV_DispatchThreadID, uint3 threadId : SV_GroupThreadID)
{
    uint index = _Offset * 2 * id.y;
    if (index >= _NumWavesPerDispatch || index + _Offset >= _NumWavesPerDispatch)
    {
        return;
    }
    if (_Offset * 2 < _NumWavesPerDispatch)
    {
        _WaveBuffer[(id.x * _NumWavesPerDispatch) + index] += _WaveBuffer[(id.x * _NumWavesPerDispatch) + index + _Offset];
    }
    else if (WaveIsFirstLane())
    {
        float3 data = _WaveBuffer[id.x * _NumWavesPerDispatch] + _WaveBuffer[(id.x * _NumWavesPerDispatch) + _Offset];
        _PositionMatrixBuffer[id.x]._m03_m13 = data.xy / data.z;
    }
}
