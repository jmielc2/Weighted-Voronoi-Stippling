#pragma target 4.5
#pragma kernel CalculateCentroid
#pragma kernel GatherData
#pragma kernel PopulateVoronoiMeshVertexData
#pragma kernel PopulateVoronoiMeshIndexData

struct VoronoiRegion {
    int2 centerOfMass;
    int totalMass;
};

struct VertexAttributes {
    float4 position;
    float3 color;
};

Texture2D _VoronoiDiagram;
RWStructuredBuffer<VoronoiRegion> _VoronoiData;
RWStructuredBuffer<float4x4> _PositionMatrixBuffer;
uint _NumRegions;
uint _ImageWidth, _ImageHeight;
float _Width, _Height;

StructuredBuffer<float3> _ConeMeshVertexBuffer;
StructuredBuffer<uint> _ConeMeshIndexBuffer;
RWStructuredBuffer<VertexAttributes> _VoronoiMeshVertexBuffer;
RWStructuredBuffer<uint> _VoronoiMeshIndexBuffer;

float2 PixelToWorldCoord(float2 pixel) {
    return float2(
        (((pixel.x + 0.5) / _ImageWidth) - 0.5) * _Width,
        (((pixel.y + 0.5) / _ImageHeight) - 0.5) * _Height
    );
}

[numthreads(8, 8, 1)]
void GatherData(uint3 id : SV_DispatchThreadID) {
    if (id.x >= _ImageWidth || id.y >= _ImageHeight) {
        return;
    }
    float4 color = _VoronoiDiagram[id.xy];
    int voronoiId = floor(color.x * _NumRegions + 0.5);
    InterlockedAdd(_VoronoiData[voronoiId].totalMass, 1);
    InterlockedAdd(_VoronoiData[voronoiId].centerOfMass.x, id.x);
    InterlockedAdd(_VoronoiData[voronoiId].centerOfMass.y, id.y);
}

[numthreads(64, 1, 1)]
void CalculateCentroid(uint3 id : SV_DispatchThreadID) {
    if (id.x >= _NumRegions) {
        return;
    }
    float2 position = _PositionMatrixBuffer[id.x]._m03_m13;
    
    // Update position here
    VoronoiRegion region = _VoronoiData[id.x];
    float2 centerOfMass = region.centerOfMass;
    float totalMass = region.totalMass;
    if (totalMass != 0) {
        centerOfMass /= totalMass;
        position.xy = PixelToWorldCoord(centerOfMass);
    }
    _PositionMatrixBuffer[id.x]._m03_m13 = position;
    
    region.centerOfMass = float2(0, 0);
    region.totalMass = 0;
    _VoronoiData[id.x] = region;
}

[numthreads(1, 64, 1)]
void PopulateVoronoiMeshVertexData(uint3 id : SV_DispatchThreadID) {
    uint numVertices = 0, _;
    _ConeMeshVertexBuffer.GetDimensions(numVertices, _);
    if (id.x >= _NumRegions || id.y >= numVertices) {
        return;
    }
    int vIndex = id.x * numVertices + id.y;
    float4 vPos = mul(_PositionMatrixBuffer[id.x], float4(_ConeMeshVertexBuffer[id.y], 1));
    float vId = float(id.x) / float(_NumRegions);
    float3 vColor = float3(vId, vId, vId);
    VertexAttributes attribute = { vPos, vColor };
    _VoronoiMeshVertexBuffer[vIndex] = attribute;
}

[numthreads(1, 64, 1)]
void PopulateVoronoiMeshIndexData(uint3 id : SV_DispatchThreadID) {
    uint numVertices = 0, numIndices = 0, _;
    _ConeMeshIndexBuffer.GetDimensions(numIndices, _);
    if (id.x >= _NumRegions || id.y >= numIndices){
        return;
    }
    _ConeMeshVertexBuffer.GetDimensions(numVertices, _);
    int vIndex = id.x * numIndices + id.y;
    uint vInd = _ConeMeshIndexBuffer[id.y] + numVertices * id.x;
    _VoronoiMeshIndexBuffer[vIndex] = vInd;
}

