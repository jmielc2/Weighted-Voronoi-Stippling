#pragma target 4.5
#pragma kernel CalculateCentroid
#pragma kernel GatherData
#pragma kernel PopulateVoronoiMeshVertexData
#pragma kernel PopulateVoronoiMeshIndexData

struct VoronoiRegion {
    int2 centerOfMass;
    int totalMass;
};

struct VertexAttributes {
    float4 position;
    float color;
};

Texture2D _VoronoiDiagram;
RWStructuredBuffer<VoronoiRegion> _VoronoiData;
RWStructuredBuffer<float4x4> _PositionMatrixBuffer;
uint _NumRegions;
uint _ImageWidth, _ImageHeight;
float _Width, _Height;

uniform StructuredBuffer<float3> _ConeMeshVertexBuffer;
uniform StructuredBuffer<uint> _ConeMeshIndexBuffer;
RWStructuredBuffer<VertexAttributes> _VoronoiMeshVertexBuffer;
RWStructuredBuffer<uint> _VoronoiMeshIndexBuffer;
uint _NumConeVertices, _NumConeIndices;

float2 PixelToWorldCoord(float2 pixel) {
    return float2(
        (((pixel.x + 0.5) / _ImageWidth) - 0.5) * _Width,
        (((pixel.y + 0.5) / _ImageHeight) - 0.5) * _Height
    );
}

[numthreads(8, 8, 1)]
void GatherData(uint3 id : SV_DispatchThreadID) {
    if (id.x >= _ImageWidth || id.y >= _ImageHeight) {
        return;
    }
    float4 color = _VoronoiDiagram[id.xy];
    int voronoiId = floor(color.x * _NumRegions + 0.5);
    InterlockedAdd(_VoronoiData[voronoiId].totalMass, 1);
    InterlockedAdd(_VoronoiData[voronoiId].centerOfMass.x, id.x);
    InterlockedAdd(_VoronoiData[voronoiId].centerOfMass.y, id.y);
}

[numthreads(64, 1, 1)]
void CalculateCentroid(uint3 id : SV_DispatchThreadID) {
    if (id.x >= _NumRegions) {
        return;
    }
    float2 position = _PositionMatrixBuffer[id.x]._m03_m13;
    
    // Update position here
    VoronoiRegion region = _VoronoiData[id.x];
    float2 centerOfMass = region.centerOfMass;
    float totalMass = region.totalMass;
    if (totalMass != 0) {
        centerOfMass /= totalMass;
        position.xy = PixelToWorldCoord(centerOfMass);
    }
    _PositionMatrixBuffer[id.x]._m03_m13 = position;
    
    region.centerOfMass = float2(0, 0);
    region.totalMass = 0;
    _VoronoiData[id.x] = region;
}

[numthreads(1, 64, 1)]
void PopulateVoronoiMeshVertexData(uint3 id : SV_DispatchThreadID) {
    if (id.x < _NumRegions && id.y < _NumConeVertices) {
        int vIndex = id.x * _NumConeVertices + id.y;
        float4 vPos = mul(_PositionMatrixBuffer[id.x], float4(_ConeMeshVertexBuffer[id.y], 1));
        float vId = float(id.x) / float(_NumRegions);
        VertexAttributes attribute = { vPos, vId };
        _VoronoiMeshVertexBuffer[vIndex] = attribute;
    }
    AllMemoryBarrierWithGroupSync();
}

[numthreads(1, 64, 1)]
void PopulateVoronoiMeshIndexData(uint3 id : SV_DispatchThreadID) {
    if (id.x < _NumRegions && id.y < _NumConeIndices) {
        int vIndex = id.x * _NumConeIndices + id.y;
        uint vInd = _ConeMeshIndexBuffer[id.y] + (_NumConeVertices * id.x);
        _VoronoiMeshIndexBuffer[vIndex] = vInd;
    }
    AllMemoryBarrierWithGroupSync();
}

